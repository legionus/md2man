package main

import (
	"fmt"
	"io"
	"log"
	"strconv"
	"strings"
	"time"

	"gopkg.in/russross/blackfriday.v2"
)

var encodeChars = []struct {
	in, out string
}{
	{`\`, "\\(rs"},
	{"$", "\\(Do"},
	{"€", "\\(Eu"},
	{"£", "\\(Po"},
	{"@", "\\(at"},
	{"'", "\\(aq"},
	{"·", "\\(bu"},
	{"©", "\\(co"},
	{"’", "\\(cq"},
	{"¢", "\\(ct"},
	{"‡", "\\(dd"},
	{"°", "\\(de"},
	{"†", "\\(dt"},
	{`"`, "\\(dq"},
	{"—", "\\(em"},
	{"–", "\\(en"},
	{"^", "\\(ha"},
	{"‐", "\\(hy"},
	{"-", "\\(hy"},
	{"{", "\\(lC"},
	{"[", "\\(lB"},
	{"<", "\\(la"},
	{"“", "\\(lq"},
	{"‘", "\\(oq"},
	{">", "\\(ra"},
	{"]", "\\(rB"},
	{"}", "\\(rC"},
	{"®", "\\(rg"},
	{"”", "\\(rq"},
	{"§", "\\(sc"},
	{"™", "\\(tm"},
	{"_", "\\(ul"},
	{"†", "\\(dt"},
	{"≡", "\\(=="},
	{"≥", "\\(>="},
	{"≤", "\\(<="},
	{"≠", "\\(!="},
	{"→", "\\(->"},
	{"←", "\\(<-"},
	{"±", "\\(+-"},
}

type roffRenderer struct {
	titleBlock  bool
	inItem      bool
	inLink      bool
	inTableHead bool
	links       []string
	table       []string
	tableAlign  []string
}

func RoffRenderer(flags int) blackfriday.Renderer {
	return &roffRenderer{}
}

func (r *roffRenderer) RenderHeader(w io.Writer, header *blackfriday.Node) {
	fmt.Fprintf(w, ".\\\" Man page was generated by md2man.\n")
}

func (r *roffRenderer) RenderFooter(w io.Writer, footer *blackfriday.Node) {
	return
}

func (r *roffRenderer) RenderNode(w io.Writer, node *blackfriday.Node, entering bool) blackfriday.WalkStatus {
	switch node.Type {
	case blackfriday.Document:
		if entering {
			break
		}
		if len(r.links) > 0 {
			fmt.Fprintf(w, "\n")
			fmt.Fprintf(w, ".SH \"REFERENCES\"\n")
			for i, url := range r.links {
				fmt.Fprintf(w, ".IP\n")
				fmt.Fprintf(w, "[%d] ", i+1)
				fmt.Fprintf(w, "%s\n", url)
				fmt.Fprintf(w, ".PD 0\n")
			}
			fmt.Fprintf(w, "\n")
		}

	case blackfriday.Heading:
		if node.IsTitleblock {
			return r.Title(w, node, entering)
		}
		return r.Header(w, node, entering)

	case blackfriday.Table:
		if entering {
			fmt.Fprintf(w, ".TS\n")
			fmt.Fprintf(w, "allbox tab(|);\n")
		} else {
			fmt.Fprintf(w, ".TE\n")
			fmt.Fprintf(w, "\n")
		}

	case blackfriday.TableHead:
		r.tableAlign = []string{}
		r.inTableHead = entering

	case blackfriday.TableBody:
		// ignore

	case blackfriday.TableRow:
		if !entering {
			if r.inTableHead {
				fmt.Fprintf(w, "%s.\n", strings.Join(r.tableAlign, ""))
			}
			fmt.Fprintf(w, "%s.\n", strings.Join(r.table, "|"))
		}
		r.table = []string{}

	case blackfriday.TableCell:
		if r.inTableHead {
			align := "l"
			switch node.Align {
			case blackfriday.TableAlignmentLeft:
				align = "l"
			case blackfriday.TableAlignmentRight:
				align = "r"
			case blackfriday.TableAlignmentCenter:
				align = "c"
			}
			r.tableAlign = append(r.tableAlign, align)
		}
		text := getDeepText(node)
		r.table = append(r.table, encodeText(text))

		return blackfriday.SkipChildren

	case blackfriday.Paragraph:
		if r.inItem {
			break
		}
		if entering {
			fmt.Fprintf(w, ".PP\n")
		} else {
			fmt.Fprintf(w, "\n\n")
		}

	case blackfriday.Item:
		if entering {
			fmt.Fprintf(w, ".IP\n\\(bu ")
		} else {
			fmt.Fprintf(w, "\n.PD 0\n")
		}
		r.inItem = entering

	case blackfriday.List:
		if !entering {
			fmt.Fprintf(w, "\n")
		}

	case blackfriday.Link:
		r.inLink = entering
		if r.inLink {
			r.links = append(r.links, string(node.Destination))
		}

	case blackfriday.Strong:
		if entering {
			fmt.Fprintf(w, "\\fB")
		} else {
			fmt.Fprintf(w, "\\fP")
		}

	case blackfriday.Emph:
		if entering {
			fmt.Fprintf(w, "\\fI")
		} else {
			fmt.Fprintf(w, "\\fP")
		}

	case blackfriday.Code:
		if entering {
			fmt.Fprintf(w, "\\fI")
			fmt.Fprintf(w, "%s", encodeText(string(node.Literal)))
			fmt.Fprintf(w, "\\fP")
		}

	case blackfriday.CodeBlock:
		if entering {
			fmt.Fprintf(w, "\n")
			fmt.Fprintf(w, ".PP\n")
			fmt.Fprintf(w, ".RS\n")
			fmt.Fprintf(w, ".nf\n")
			fmt.Fprintf(w, "%s", encodeText(string(node.Literal)))
			fmt.Fprintf(w, "\n")
			fmt.Fprintf(w, ".fi\n")
			fmt.Fprintf(w, ".RE\n")
		}

	case blackfriday.Text:
		text := string(node.Literal)
		text = strings.ReplaceAll(text, "\n", "\n.br\n")

		fmt.Fprintf(w, "%s", encodeText(text))

		if r.inLink {
			fmt.Fprintf(w, " [%d]", len(r.links))
		}

	default:
		p := ""
		if !entering {
			p = "/"
		}
		fmt.Fprintf(w, "{%s%s} %q\n", p, node.Type.String(), node.Literal)
	}

	return blackfriday.GoToNext
}

func (r *roffRenderer) Title(w io.Writer, node *blackfriday.Node, entering bool) blackfriday.WalkStatus {
	if !entering {
		return blackfriday.GoToNext
	}

	r.titleBlock = true

	var (
		num  int
		text string
		date string
	)

	text = "Unknown"
	if node.LastChild != nil {
		text = encodeText(getDeepText(node))
	}

	arr := strings.Split(text, " ")
	if len(arr) < 2 {
		log.Fatalf("unable to parse document title")
	}

	num, err := strconv.Atoi(arr[len(arr)-1])
	if err != nil {
		log.Fatalf("unable to parse man page number: %s: %s", arr[1], err)
	}

	text = strings.Join(arr[0:len(arr)-1], " ")
	date = time.Now().Format("2 January 2006")

	fmt.Fprintf(w, ".TH %q %d %q\n", text, num, date)
	return blackfriday.SkipChildren
}

func (r *roffRenderer) Header(w io.Writer, node *blackfriday.Node, entering bool) blackfriday.WalkStatus {
	if !entering {
		return blackfriday.GoToNext
	}

	level := node.Level

	if !r.titleBlock {
		r.titleBlock = true
		level = 0
	}

	text := "NONE"
	if node.LastChild != nil {
		text = encodeText(getDeepText(node))
	}

	switch level {
	case 0:
		fmt.Fprintf(w, ".TH %q 1 %q\n", text, time.Now().Format("2 January 2006"))
		fmt.Fprintf(w, ".SH ")
	case 1, 2:
		fmt.Fprintf(w, ".SH ")
	default:
		fmt.Fprintf(w, ".SS ")
	}
	fmt.Fprintf(w, "%q\n", text)

	return blackfriday.SkipChildren
}

func getDeepText(node *blackfriday.Node) string {
	text := ""
	node.Walk(func(node *blackfriday.Node, entering bool) blackfriday.WalkStatus {
		text += string(node.Literal)
		return blackfriday.GoToNext
	})
	return text
}

func encodeText(text string) string {
	for _, sub := range encodeChars {
		text = strings.ReplaceAll(text, sub.in, sub.out)
	}
	return text
}
